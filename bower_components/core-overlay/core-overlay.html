<!--
    @license
    Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="event-utils.html">
<link rel="import" href="overlay-manager.html">
<link rel="import" href="overlay-positioner.html">

<!--
The `core-overlay` element displays overlayed on top of other content. It starts
out hidden and is displayed by setting its `opened` property to true.
A `core-overlay's` opened state can be toggled by calling the `toggle`
method.

The `core-overlay` will, by default, show/hide itself when it's opened. The
`target` property may be set to another element to cause that element to
be shown when the overlay is opened.

It's common to want a `core-overlay` to animate to its opened
position. The `core-overlay` element uses a `core-transition` to handle
animation. The default transition is `core-transition-fade` which
causes the overlay to fade in when displayed. See
<a href="../core-transition/">`core-transition`</a> for more
information about customizing a `core-overlay's` opening animation. The
`backdrop` property can be set to true to show a backdrop behind the overlay
that will darken the rest of the window.

An element that should close the `core-overlay` will automatically
do so if it's given the `core-overlay-toggle` attribute. This attribute
can be customized with the `closeAttribute` property. You can also use
`closeSelector` if more general matching is needed.

By default  `core-overlay` will close whenever the user taps outside it or
presses the escape key. This behavior can be turned off via the
`autoCloseDisabled` property.

    <core-overlay>
      <h2>Dialog</h2>
      <input placeholder="say something..." autofocus>
      <div>I agree with this wholeheartedly.</div>
      <button core-overlay-toggle>OK</button>
    </core-overlay>

`core-overlay` will automatically size and position itself according to the
following rules. The overlay's size is constrained such that it does not
overflow the screen. This is done by setting maxHeight/maxWidth on the
`sizingTarget`. If the `sizingTarget` already has a setting for one of these
properties, it will not be overridden. The overlay should
be positioned via css or imperatively using the `core-overlay-position` event.
If the overlay is not positioned vertically via setting `top` or `bottom`, it
will be centered vertically. The same is true horizontally via a setting to
`left` or `right`. In addition, css `margin` can be used to provide some space
around the overlay. This can be used to ensure
that, for example, a drop shadow is always visible around the overlay.

@group Core Elements
@element core-overlay
@mixins Polymer.CoreResizer https://github.com/polymer/core-resizable
@homepage github.io
-->
<!--
Fired when the `core-overlay`'s `opened` property changes.

@event core-overlay-open
@param {Object} detail
@param {Object} detail.opened the opened state
-->
<!--
Fired when the `core-overlay` has completely opened.

@event core-overlay-open-completed
-->
<!--
Fired when the `core-overlay` has completely closed.

@event core-overlay-close-completed
-->
<!--
Fired when the `core-overlay` needs to position itself. Optionally, implement
in order to position an overlay via code. If the overlay was not otherwise
positioned, it's important to indicate how the overlay has been positioned by
setting the `dimensions.position` object. For example, if the overlay has been
positioned via setting `right` and `top`, set dimensions.position to an
object like this: `{v: 'top', h: 'right'}`.

@event core-overlay-position
@param {Object} detail
@param {Object} detail.target the overlay target
@param {Object} detail.sizingTarget the overlay sizing target
@param {Object} detail.opened the opened state
-->

<!--
Fired when the user cancels the `core-overlay`.

@event core-overlay-cancel
@param {Object} detail
@param {Object} detail.target the overlay target
-->

<style>

  /* backdrop styles are global */
  /* FIXME: encapsulate in an element */
  .core-overlay-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: black;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .core-overlay-backdrop.core-opened {
    opacity: 0.6;
  }

</style>

<dom-module id="core-overlay">

  <style>

    :host {
      position: fixed;
      background: #fff;
    }

  </style>

</dom-module>

<script>

  (function() {

    var manager = Polymer.Core.Overlay.Manager;

    Polymer({

      is: 'core-overlay',

      mixins: [
        Polymer.Core.Overlay.Positioner,
        Polymer.Core.EventUtils
      ],

      properties: {

        /**
         * A `core-overlay`'s size is guaranteed to be
         * constrained to the window size. To achieve this, the sizingElement
         * is sized with a max-height/width. By default this element is the
         * target element, but it can be specifically set to a specific element
         * inside the target if that is more appropriate. This is useful, for
         * example, when a region inside the overlay should scroll if needed.
         *
         * @attribute sizingTarget
         * @type Object
         * @default this
         */
        sizingTarget: {
          type: Object,
          value: function() {
            return this;
          }
        },

        /**
         * Set opened to true to show an overlay and to false to hide it.
         * A `core-overlay` may be made initially opened by setting its
         * `opened` attribute.
         * @attribute opened
         * @type boolean
         * @default false
         */
        opened: {
          type: Boolean,
          value: false,
          observer: 'openedChanged'
        },

        /**
         * If true, the overlay has a backdrop darkening the rest of the screen.
         * The backdrop element is attached to the document body and may be styled
         * with the class `core-overlay-backdrop`. When opened the `core-opened`
         * class is applied.
         *
         * @attribute backdrop
         * @type boolean
         * @default false
         */
        backdrop: {
          type: Boolean,
          value: false
        },

        /**
         * If true, the overlay is reparented to document.body and given so it can be guaranteed to
         * display on top.
         * TODO: write docs about caveats
         *
         * @attribute alwaysOnTop
         * @type boolean
         * @default false
         */
        alwaysOnTop: {
          type: Boolean,
          value: false
        },

        /**
         * If true, the ESC key does not cancel the overlay.
         *
         * @attribute noCancelOnEscKey
         * @type boolean
         * @default false
         */
        noCancelOnEscKey: {
          type: Boolean,
          value: false
        },

        /**
         * If true, clicking outside the overlay does not cancel the overlay.
         *
         * @attribute noCancelOnOutsideClick
         * @type boolean
         * @default false
         */
        noCancelOnOutsideClick: {
          type: Boolean,
          value: false
        }

      },

      get backdropElement() {
        return this._backdrop;
      },

      registered: function() {
        // All instances of core-overlay share these elements
        this._layer = document.createElement('core-overlay-layer');
        this._backdrop = document.createElement('div');
        this._backdrop.className = 'core-overlay-backdrop';
      },

      ready: function() {
        this.addElementListener(this, 'click', 'onClick');
        this.ensureTargetSetup();
      },

      detached: function() {
        this.opened = false;
        this.completeBackdrop();
        manager.removeOverlay(this);
      },

      /**
       * Toggle the opened state of the overlay.
       *
       * @method toggle
       */
      toggle: function() {
        this.opened = !this.opened;
      },

      /**
       * Open the overlay. This is equivalent to setting the `opened`
       * property to true.
       *
       * @method open
       */
      open: function() {
        this.opened = true;
      },

      /**
       * Close the overlay. This is equivalent to setting the `opened`
       * property to false.
       *
       * @method close
       */
      close: function() {
        this.opened = false;
      },

      /**
       * Cancels the overlay.
       *
       * @method cancel
       */
      cancel: function() {
        this.opened = false,
        this.fire('core-overlay-cancel', {target: this});
      },

      // NOTE: wait to call this until we're as sure as possible that target
      // is styled.
      ensureTargetSetup: function() {
        if (this.__overlaySetup) {
          return;
        }
        this.__overlaySetup = true;
        var style = this.style;
        style.outline = 'none';
        style.display = 'none';
      },

      openedChanged: function() {
        if (this._openChangedAsync) {
          this.cancelAsync(this._openChangedAsync);
        }

        this.transitioning = true;

        this.ensureTargetSetup();
        this.prepareRenderOpened();

        // async here to allow overlay layer to become visible.
        this._openChangedAsync = this.async(function() {
          this.style.display = '';
          // force layout to ensure transitions will go
          this.offsetWidth;
          this.renderOpened();
          this._openChangedAsync = null;
        });

        this.fire('core-overlay-open', {
          opened: this.opened
        });
      },

      // tasks which must occur before opening; e.g. making the element visible
      prepareRenderOpened: function() {
        if (this._prepareRenderOpenedAsync) {
          this.cancelAsync(this._prepareRenderOpenedAsync);
        }

        if (this.opened) {
          manager.addOverlay(this);
        }
        this.prepareBackdrop();
        // async so we don't auto-close immediately via a click.
        this._prepareRenderOpenedAsync = this.async(function() {
          this.enableElementListener(this.opened, document, 'click', 'onCaptureClick', true);
          this.enableElementListener(this.opened, document, 'keydown', 'onCaptureKeydown', true);
          this._prepareRenderOpenedAsync = null;
        });
        this.enableElementListener(this.opened, window, 'resize',
            'resizeHandler');

        if (this.opened) {
          // force layout so SD Polyfill renders
          this.offsetHeight;
          this.discoverDimensions();
          // if we are showing, then take care when positioning
          this.preparePositioning();
          this.positionTarget();
          this.updateTargetDimensions();
          this.finishPositioning();

          // reparent the element if always on top
          if (this.alwaysOnTop) {
            this._layer.addElement(this);
            this._layer.opened = this.opened;
          }
        }
      },

      // tasks which cause the overlay to actually open; typically play an
      // animation
      renderOpened: function() {
        // this.notifyResize();
        this.renderBackdropOpened();
        // var transition = this.getTransition();
        // if (transition) {
        //   transition.go(this, {opened: this.opened});
        // } else {
          this.transitionend();
        // }
      },

      // finishing tasks; typically called via a transition
      transitionend: function(e) {
        // make sure this is our transition event.
        if (e && e.target !== this) {
          return;
        }
        this.transitioning = false;
        if (!this.opened) {
          this.resetTargetDimensions();
          this.style.display = 'none';
          this.completeBackdrop();
          manager.removeOverlay(this);

          // remove the element from this._layer if always on top
          if (this.alwaysOnTop) {
            if (!currentOverlay()) {
              this._layer.opened = this.opened;
            }
            this._layer.removeElement(this.target);
          }
        }

        this.applyFocus();

        // complete all tasks before firing -completed event
        this.fire('core-overlay-' + (this.opened ? 'open' : 'close') +
            '-completed');
      },

      prepareBackdrop: function() {
        if (this.backdrop && this.opened) {
          if (!this._backdrop.parentNode) {
            Polymer.dom(document.body).appendChild(this._backdrop);
            this._backdrop.style.zIndex = manager.currentOverlayZ() - 1;
          }
          manager.trackBackdrop(this);
        }
      },

      renderBackdropOpened: function() {
        if (this.backdrop && manager.getBackdrops().length < 2) {
          this._backdrop.classList.toggle('core-opened', this.opened);
        }
      },

      completeBackdrop: function() {
        if (this.backdrop) {
          manager.trackBackdrop(this);
          if (manager.getBackdrops().length === 0 && this._backdrop.parentNode) {
            Polymer.dom(this._backdrop.parentNode).removeChild(this._backdrop);
          }
        }
      },

      preparePositioning: function() {
        this.style.transition = this.style.webkitTransition = 'none';
        this.style.transform = this.style.webkitTransform = 'none';
        this.style.display = '';
      },

      finishPositioning: function(target) {
        this.style.display = 'none';
        this.style.transform = this.style.webkitTransform = '';
        // force layout to avoid application of transform
        this.offsetWidth;
        this.style.transition = this.style.webkitTransition = '';
      },

      getFocusNode: function() {
        return Polymer.dom(this).querySelector('[autofocus]') || this;
      },

      applyFocus: function() {
        var focusNode = this.getFocusNode();
        if (this.opened) {
          if (!this.autoFocusDisabled) {
            focusNode.focus();
          }
        } else {
          focusNode.blur();
          if (manager.currentOverlay() == this) {
            console.warn('Current core-overlay is attempting to focus itself as next! (bug)');
          } else {
            manager.focusOverlay();
          }
        }
      },

      // We use the traditional approach of capturing events on document
      // to to determine if the overlay needs to close. However, due to
      // ShadowDOM event retargeting, the event target is not useful. Instead
      // of using it, we attempt to close asynchronously and prevent the close
      // if a tap event is immediately heard on the target.
      // TODO(sorvell): This approach will not work with modal. For
      // this we need a scrim.
      onCaptureClick: function() {
        if (!this.noCancelOnOutsideClick && (manager.currentOverlay() == this)) {
          this.cancelJob = this.async(function() {
            this.cancel();
          }, 10);
        }
      },

      onClick: function(event) {
        if (this.cancelJob) {
          this.cancelAsync(this.cancelJob);
          this.cancelJob = null;
        }
      },

      onCaptureKeydown: function(event) {
      if (!this.noCancelOnEscKey && (event.keyCode === this.eventKeyCodes.ESC_KEY)) {
          this.cancel();
          event.stopPropagation();
        }
      },

      /**
       * Extensions of core-overlay should implement the `resizeHandler`
       * method to adjust the size and position of the overlay when the
       * browser window resizes.
       * @method resizeHandler
       */
      resizeHandler: function() {
        this.updateTargetDimensions();
      }

    });

  })();

</script>
